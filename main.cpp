//
//  main.cpp
//  libuuidpp tests
//
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//

#include <iostream>
#include <vector>
#include <map>
#include <set>
#include <algorithm>
#include <unordered_set>

#if __cplusplus == 201703		// C++17 std::optional support
#define UUID_OPTIONAL_SUPPORT 1
#include <optional>
#endif

#include "libuuidpp/libuuidpp.hpp"

/// Simple test harness

#define DSF_ASSERT(ASSERTION) if (!(ASSERTION)) \
{ std::cerr << "ASSERTION: Line " << __LINE__ << ", file: " << __FILE__ << "\n"; abort(); }
#define DSF_ASSERT_FALSE(ASSERTION, msg) if ((ASSERTION)) \
{ std::cerr << "ASSERTION: Line " << __LINE__ << ", file: " << __FILE__ << ", message: '" << msg << "'\n"; abort(); }
#define DSF_ASSERT_MSG(ASSERTION, msg) if (!(ASSERTION)) \
{ std::cerr << "ASSERTION: Line " << __LINE__ << ", file: " << __FILE__ << ", message: '" << msg << "'\n"; abort(); }
#define DSF_ASSERT_EQUAL(AVAL, BVAL, msg) if ((AVAL) != (BVAL)) \
{ std::cerr << "ASSERTION: Line " << __LINE__ << ", file: " << __FILE__ << ", message: '" << msg << "'\n"; abort(); }
#define DSF_ASSERT_NOTEQUAL(AVAL, BVAL, msg) if ((AVAL) == (BVAL)) \
{ std::cerr << "ASSERTION: Line " << __LINE__ << ", file: " << __FILE__ << ", message: '" << msg << "'\n"; abort(); }

void testSimple() {

	std::cout << "Running test: testSimple" << std::endl;

	DSF_ASSERT(libuuidpp::uuid::nil.is_nil());

	const auto& nilUUID = libuuidpp::uuid::nil;
	DSF_ASSERT(nilUUID.is_nil());

	// Check that the static nil object is created only once (addresses should be the same)
	DSF_ASSERT(&libuuidpp::uuid::nil == &libuuidpp::uuid::nil);

	// Random guid creation

	libuuidpp::uuid c1 = libuuidpp::uuid::create();
	libuuidpp::uuid c2 = libuuidpp::uuid::create();

	DSF_ASSERT_NOTEQUAL(c1, c2, "Random guids are the same!");

	// nil guid creation

	libuuidpp::uuid n1, n2;
	DSF_ASSERT_EQUAL(n1, n2, "generated uuids are equal");
	DSF_ASSERT_NOTEQUAL(n1, c1, "random and nil guids are equal?");

	uuid_t rawValue;
	::uuid_generate(rawValue);
	libuuidpp::uuid c3(rawValue);

	::uuid_string_t stringVal;
	::uuid_unparse_upper(rawValue, stringVal);

	auto rawString = std::string(stringVal);
	DSF_ASSERT_EQUAL(rawString, c3.string(), "generated string are not equal");

	// Generate some random guids - check for uniqueness (dumb test really)
	std::set<libuuidpp::uuid> group;

	// Check that duplicated items are not stored in a set
	group.insert("C06C892B-50AB-4585-9819-5F4BA3B8F69B");
	group.insert("{C06C892B-50AB-4585-9819-5F4BA3B8F69B}");
	group.insert("{c06c892b-50ab-4585-9819-5f4ba3b8f69b}");
	DSF_ASSERT_EQUAL(1, group.size(), "Supposedly unique items are not unique");

	// Add 100000 guids, any duplicates will have been removed so check for exact count
	group.clear();
	const size_t count = 100000;
	for (size_t i = 0; i < count; i++) {
		group.insert(libuuidpp::uuid::create());
	}
	DSF_ASSERT_EQUAL(count, group.size(), "Generated some non-unique uuids");
}

void testBinary() {
	std::cout << "Running test: testBinary" << std::endl;

	libuuidpp::uuid::binary rawData {
		0xa0, 0x47, 0x87, 0x99, 0xa6, 0xdd, 0x46, 0x37, 0xa8, 0xaa, 0x87, 0xf6, 0xeb, 0x01, 0x43, 0x17
	};
	libuuidpp::uuid raw(rawData);
	DSF_ASSERT_EQUAL(raw.string(libuuidpp::uuid::formatting::lowercase),
					 "a0478799-a6dd-4637-a8aa-87f6eb014317",
					 "Binary data didn't match the string data?");

	const auto roundTrip = raw.data();
	DSF_ASSERT_EQUAL(rawData, roundTrip, "Return trip raw data convert failed")

	libuuidpp::uuid valString("{C06C892B-50AB-4585-9819-5F4BA3B8F69B}");
	libuuidpp::uuid::binary valueExpected {
		0xc0, 0x6c, 0x89, 0x2b, 0x50, 0xab, 0x45, 0x85, 0x98, 0x19, 0x5f, 0x4b, 0xa3, 0xb8, 0xf6, 0x9b
	};
	const auto valBinary = valString.data();
	DSF_ASSERT_EQUAL(valBinary,
					 valueExpected,
					 "Return trip raw data convert failed")
}

void testHashing() {
	std::cout << "Running test: testHashing" << std::endl;

	const auto s1 = libuuidpp::uuid::create();
	const auto s2 = libuuidpp::uuid::create();
	const auto& nil = libuuidpp::uuid::nil;

	DSF_ASSERT_EQUAL(nil.hash(), nil.hash(), "Null hash values should be equal");
	DSF_ASSERT_EQUAL(s1.hash(), s1.hash(), "Same uuid generated different hashes");
	DSF_ASSERT_NOTEQUAL(s1.hash(), s2.hash(), "Hash values should be different");
	DSF_ASSERT_NOTEQUAL(s1.hash(), nil.hash(), "Hash values should be different");

	std::unordered_set<libuuidpp::uuid> unorderedSet { s1, s2, s2, nil, nil };
	DSF_ASSERT_EQUAL(3, unorderedSet.size(), "Expecting 3 elements");

	unorderedSet.clear();
	const size_t count = 100000;
	for (size_t i = 0; i < count; i++) {
		unorderedSet.insert(libuuidpp::uuid::create());
	}
	DSF_ASSERT_EQUAL(count, unorderedSet.size(), "Mismatch in unordered_set size - unexpected hashing clash");

	unorderedSet.clear();

	// Create 'count' random guids
	for (size_t i = 0; i < count; i++) {
		unorderedSet.insert(libuuidpp::uuid::create());
	}

	std::set<std::size_t> hashes;
	std::for_each(unorderedSet.begin(), unorderedSet.end(), [&hashes](const libuuidpp::uuid& element) {
		hashes.insert(element.hash());
	});

	// All of the hashes should be unique. Hashes uses a set, so duplicates will be removed
	DSF_ASSERT_EQUAL(count, hashes.size(), "Found duplicates");
}

void testInvalid() {
	std::cout << "Running test: testInvalid" << std::endl;

	libuuidpp::uuid test1;

	// Make sure that we can successfully parse a goodun
	DSF_ASSERT(test1.set("C06C892B-50AB-4585-9819-5F4BA3B8F69B") == true);
	DSF_ASSERT_FALSE(test1.is_nil(), "Correct uuid string should not be nil");

	// Length and bracket checks

	// Check that invalid set automatically sets the value to nil
	DSF_ASSERT_FALSE(test1.set("C56A4180-65AA-42EC-A945-5FD21DEC"), "Invalid uuid string should create nil uuid");
	DSF_ASSERT(test1.is_nil());

	// Static validation methods
	DSF_ASSERT(libuuidpp::uuid::is_valid("C06C892B-50AB-4585-9819-5F4BA3B8F69B"));
	DSF_ASSERT(libuuidpp::uuid::is_valid("{e8e3db08-dc39-48ea-a3db-08dc3958eafb}"));
	DSF_ASSERT(libuuidpp::uuid::is_valid("{29C49537-2BD1-4DA1-887A-5D0B93514BAD}"));

	DSF_ASSERT_FALSE(libuuidpp::uuid::is_valid("{29C49537-2xD1-4DA1-887A-5D0B93514BAD}"), "Invalid uuid string should create nil uuid");
	DSF_ASSERT_FALSE(libuuidpp::uuid::is_valid(" 33aff347-1028-4fb2-86c7-2cdf06ef3610}"), "Invalid uuid string should create nil uuid");

	// Correctly formatted uuid should contain - separators
	DSF_ASSERT_FALSE(libuuidpp::uuid::is_valid("6D059566588D4BF081933253FAFD1426"), "Invalid uuid string should create nil uuid");

	// Series of badly formatted
	DSF_ASSERT_FALSE(test1.set(" C06C892B-50AB-4585-9819-5F4BA3B8F69B"), "Invalid uuid string should create nil uuid");
	DSF_ASSERT_FALSE(test1.set("{8078cbe9-2b91-4d82-9e8a-8d27ca5fcfa8"), "Invalid uuid string should create nil uuid");
	DSF_ASSERT_FALSE(test1.set("C06C892B-50AB-4585-9819-5F4BA3B8F69B}"), "Invalid uuid string should create nil uuid");
	DSF_ASSERT_FALSE(test1.set("{C06C892B-50AB-4585-9819-5F4BA3B8F69B}    "), "Invalid uuid string should create nil uuid");
	DSF_ASSERT_FALSE(test1.set("{C06C892B-50AB-4585-9819-5F4BA3B8F69BA}"), "Invalid uuid string should create nil uuid");
	DSF_ASSERT_FALSE(test1.set("C06C892B-50AB-4585-9819-5F4BA3B8F69BAA"), "Invalid uuid string should create nil uuid");
	DSF_ASSERT_FALSE(test1.set("{C06C892B-50AB-4585-9819-5F4BA3B8F69BA"), "Invalid uuid string should create nil uuid");
	DSF_ASSERT_FALSE(test1.set("{ C06C892B-50AB-4585-9819-5F4BA3B8F69B}"), "Invalid uuid string should create nil uuid");

	// Invalid chars in the guid
	DSF_ASSERT_FALSE(test1.set("{C06C892B-50AB-4585-9819-5F4&A3B8F69B}"), "Invalid uuid string should create nil uuid");
	DSF_ASSERT_FALSE(test1.set("C06C892B-50XB-4585-9819-5F4A3B8F69B"), "Invalid uuid string should create nil uuid");

	// Invalid empty string
	DSF_ASSERT_FALSE(test1.set(""), "Invalid uuid string should create nil uuid");
	DSF_ASSERT_FALSE(libuuidpp::uuid::is_valid(nullptr), "Invalid uuid string should create nil uuid");
	DSF_ASSERT_FALSE(libuuidpp::uuid::is_valid(NULL), "Invalid uuid string should create nil uuid");
}

void testMap() {
	std::cout << "Running test: testMap" << std::endl;

	/// Adding to a map as the key
	std::map<libuuidpp::uuid, std::string> values;
	libuuidpp::uuid g1("C06C892B-50AB-4585-9819-5F4BA3B8F69B");
	libuuidpp::uuid g11("{C06C892B-50AB-4585-9819-5F4BA3B8F69B}");
	libuuidpp::uuid g2("D1ABE846-63D3-4C0A-89EF-68F1A306F6D3");
	libuuidpp::uuid g3("F211F534-8DFB-4269-9AF1-245FA0AB8D87");
	values[g1] = "this is a uuid";
	values[g2] = "this is another uuid";

	DSF_ASSERT(values[g1] == "this is a uuid");
	DSF_ASSERT(values[g11] == "this is a uuid");
	DSF_ASSERT(values[g2] == "this is another uuid");

	/// As g3 doesn't exist in the map, the [] operator adds g3 with a default std::string value
	DSF_ASSERT(values[g3] == "");

	/// Adding to a map as the valuetype
	std::map<std::string, libuuidpp::uuid> mapper;
	mapper["cat"] = g1;
	mapper["dog"] = g2;

	const auto& m1 = mapper["cat"];
	const auto& m2 = mapper["dog"];
	DSF_ASSERT(!m1.is_nil());
	DSF_ASSERT(!m2.is_nil());

	/// Asking for a key that doesn't exist returns a null guid.
	auto ret = mapper.find("caterpillar");
	DSF_ASSERT(ret == mapper.end());

	const auto& m3 = mapper["caterpillar"];
	DSF_ASSERT(m3.is_nil());

	// Set stuff

	std::set<libuuidpp::uuid> uuids = { g3, g11, g2, g1 };

	// g1 and g11 are the same uuid (even though they have different strings during creation)
	DSF_ASSERT(uuids.size() == 3);

	std::vector<std::string> uuidStrings;
	std::transform(uuids.begin(), uuids.end(),
				   std::back_inserter(uuidStrings),
				   [](const libuuidpp::uuid& uuid) -> std::string
				   {
					   return uuid.string(libuuidpp::uuid::formatting::lowercase | libuuidpp::uuid::formatting::brackets);
				   });

	std::vector<std::string> expected = {
		"{c06c892b-50ab-4585-9819-5f4ba3b8f69b}",
		"{d1abe846-63d3-4c0a-89ef-68f1a306f6d3}",
		"{f211f534-8dfb-4269-9af1-245fa0ab8d87}" };

	DSF_ASSERT(uuidStrings == expected);

}

void testAssign() {

	std::cout << "Running test: testAssign" << std::endl;

#if defined(UUID_OPTIONAL_SUPPORT)
	std::optional<libuuidpp::uuid> temp1;
	try {
		temp1 = std::make_optional(libuuidpp::uuid("This should fail"));
		std::cerr << "Didn't catch exception during creation" << std::endl;
		DSF_ASSERT(false);
	} catch (libuuidpp::exception::invalid_uuid e) {
		std::cout << "Successfully caught exception during creation" << std::endl;
	}

	std::optional<libuuidpp::uuid> temp2;
	try {
		temp2 = std::make_optional(libuuidpp::uuid("C06C892B-50AB-4585-9819-5F4BA3B8F69B"));
	} catch (libuuidpp::exception::invalid_uuid e) {
		std::cout << "Caught exception during creation of valid uuid" << std::endl;
		DSF_ASSERT(false);
	}

	auto tempStr = temp2->string();
	DSF_ASSERT(tempStr == "C06C892B-50AB-4585-9819-5F4BA3B8F69B");
#endif

	auto c1 = libuuidpp::uuid::create();
	libuuidpp::uuid c2 = c1;
	DSF_ASSERT(c1 == c2); // "Random guids are the same!"

	auto s1 = c1.string();
	libuuidpp::uuid c3(s1.c_str());
	DSF_ASSERT(c1 == c3);

	DSF_ASSERT(c1.is_nil() == false);

	const auto& nil = libuuidpp::uuid::nil;
	DSF_ASSERT(nil.is_nil());
	DSF_ASSERT(nil != c1);

	c1.set_nil();
	DSF_ASSERT(c1.is_nil());

	c1.set_random();
	DSF_ASSERT(c1 != c3);

	std::string stdguid = "D1ABE846-63D3-4C0A-89EF-68F1A306F6D3";
	auto stdguid1 = libuuidpp::uuid(stdguid.c_str());
	auto sg2 = stdguid1.string();
	DSF_ASSERT(stdguid == sg2);
}

void testMSGuid() {

	std::cout << "Running test: testMSGuid" << std::endl;

	std::string msGuid = "{D1ABE846-63D3-4C0A-89EF-68F1A306F6D3}";
	std::string sGuid = "D1ABE846-63D3-4C0A-89EF-68F1A306F6D3";
	std::string sGuidl = "d1abe846-63d3-4c0a-89ef-68f1a306f6d3";

	auto msGuid2 = libuuidpp::uuid(msGuid);
	auto sGuid2 = libuuidpp::uuid(sGuid);
	auto sGuidl2 = libuuidpp::uuid(sGuidl);
	DSF_ASSERT(msGuid2 == sGuid2);

	/// Check that a lowercase version matches
	DSF_ASSERT(msGuid2 == sGuidl2);

	auto s2 = msGuid2.string(libuuidpp::uuid::formatting::brackets);
	DSF_ASSERT(msGuid == s2);

	auto s3 = sGuid2.string();
	DSF_ASSERT(sGuid == s3);

	auto s4 = sGuidl2.string(libuuidpp::uuid::formatting::lowercase);
	DSF_ASSERT(sGuidl == s4);

	auto s5 = sGuidl2.string(libuuidpp::uuid::formatting::lowercase | libuuidpp::uuid::formatting::brackets);
	DSF_ASSERT(sGuidl == s4);
}

void testUpperLower() {

	std::cout << "Running test: testUpperLower" << std::endl;

	std::string sGuid = "D1ABE846-63D3-4C0A-89EF-68F1A306F6D3";
	std::string sGuidl = "d1abe846-63d3-4c0a-89ef-68f1a306f6d3";
	std::string sGuidlb = "{d1abe846-63d3-4c0a-89ef-68f1a306f6d3}";
	std::string sGuidub = "{D1ABE846-63D3-4C0A-89EF-68F1A306F6D3}";

	std::vector<libuuidpp::uuid> vals = { sGuid, sGuidl, sGuidlb, sGuidub };
	std::vector<std::string> expected(4, "D1ABE846-63D3-4C0A-89EF-68F1A306F6D3");

	// Maps the vals vector to their string equivalents
	std::vector<std::string> uuidStrings;
	std::transform(vals.begin(), vals.end(),
				   std::back_inserter(uuidStrings),
				   [](const libuuidpp::uuid& uuid) -> std::string
	{
		return uuid.string();
	});
	DSF_ASSERT(uuidStrings == expected);

	auto sGuid2 = libuuidpp::uuid(sGuid);
	auto sGuidl2 = libuuidpp::uuid(sGuidl);
	DSF_ASSERT(sGuid2 == sGuidl2);

	auto s3 = sGuid2.string();
	DSF_ASSERT(sGuid == s3);

	auto s4 = sGuidl2.string(libuuidpp::uuid::formatting::lowercase);
	DSF_ASSERT(sGuidl == s4);

	auto s5 = sGuidl2.string();
	DSF_ASSERT(s4 != s5);

	auto s6 = sGuidl2.string(libuuidpp::uuid::formatting::lowercase | libuuidpp::uuid::formatting::brackets);
	DSF_ASSERT(s6 == sGuidlb);
}

void testOrdering() {

	std::cout << "Running test: testOrdering" << std::endl;

	std::vector<libuuidpp::uuid> result1;
	std::vector<libuuidpp::uuid> result2;
	for (size_t c = 0; c < 10; c++) {
		result1.push_back(libuuidpp::uuid::create());
	}
	for (size_t c = 0; c < 10; c++) {
		result2.push_back(libuuidpp::uuid::create());
	}

	DSF_ASSERT(result1 != result2);

	auto result3 = result1;
	DSF_ASSERT(result1 == result3);

	std::sort(result1.begin(), result1.end(), std::less<libuuidpp::uuid>());
	DSF_ASSERT(result1 != result3);
	std::sort(result3.begin(), result3.end(), std::less<libuuidpp::uuid>());
	DSF_ASSERT(result1 == result3);

	auto find = std::find(result1.begin(), result1.end(), libuuidpp::uuid::nil);
	DSF_ASSERT(find == result1.end());

	auto duplicate = std::adjacent_find(result1.begin(), result1.end());
	DSF_ASSERT(duplicate == result1.end());

	std::vector<libuuidpp::uuid> result4;
	for (size_t c = 0; c < 100; c++) {
		result4.push_back(libuuidpp::uuid::create());
	}
	duplicate = std::adjacent_find(result4.begin(), result4.end());
	std::sort(result4.begin(), result4.end());
	DSF_ASSERT(duplicate == result4.end());

	result4.push_back(result4[2]);
	std::sort(result4.begin(), result4.end());
	duplicate = std::adjacent_find(result4.begin(), result4.end());
	DSF_ASSERT(duplicate != result4.end());
}

int main(int argc, const char * argv[]) {
	// insert code here...
	std::cout << "Starting tests...\n";

	testSimple();
	testBinary();
	testInvalid();
	testMap();
	testHashing();
	testAssign();
	testOrdering();
	testMSGuid();
	testUpperLower();

	std::cout << "... tests complete\n";

	return 0;
}


